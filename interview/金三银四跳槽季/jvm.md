#### 详细jvm内存模型
（深入理解jvm那本书讲得很好）
- 主内存和工作内存
- 内存间交互操作
- volatile型变量的特殊规则
- 对于龙和double型变量的特殊规则
- 原子性，可见性和有序性
- happens-before原则
#### 讲讲什么情况下回出现内存溢出，内存泄漏？
- 内存溢出：用专业点的语言来说内存溢出，就是你申请内存容量的时候，系统无法给到你足够的内存容量大小，你申请了一个Integer类型的大小空间，但是你却往里面放long类型才能存的下的数据，这个时候就会内存溢出（Out Of Memory）。
- 内存泄露：你向系统申请到了你想要的内存空间（new），但是使用完了之后却不归还（delete），结果你申请到的内存空间你自己也访问不到（也许你把地址搞丢了），系统也无法分配该空间给其他的程序。这就是一次泄漏。内存泄漏的堆积，时间长了，你的内存空间会一点点的变小，**Memory leak最终会导致Out Of Memory**,因为你的可用的内存空间会越来越小，可分配给其他程序的容量也越来越小，很容易就会造成OOM. 
- **如何定位内存泄露：jmap -histo:live [pid]** 可以看到每个对象的存活情况，包括有多少个对象，占用多少字节。
https://blog.csdn.net/aasgis6u/article/details/54928744
#### 说说Java线程栈 
- jstack：查看线程快照
- java虚拟机栈：每个方法在执行的同时都会创建一个帧栈用于存储局部变量表，炒作数栈，动态链接，方法出口等。每一个方法从调用到执行完成的过程，对应着一个帧栈在虚拟机中入栈到出栈的过程。
#### JVM 年轻代到年老代的晋升过程的判断条件是什么呢？
- 年龄到了就进入老年代（默认15次，每Minor GC一个年龄就加1，可以设置MaxTenuringThreshold大小设置次数）
- 大对象直接进入老年代（可以设置PretenureSizeThreshold大小）
- 动态对象年龄判定：如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代。
#### JVM 出现 fullGC 很频繁，怎么去线上排查问题？
https://www.zhihu.com/question/23512213
- 查看代码中是否显示调用了System.gc(),在代码中显示调用会触发full GC。Full GC堆整个堆进行整理，包括Young、Tenured和Perm，所以比Scavenge GC要慢。
- 老年代是否被写满。
	- 看日志，gc之后老年代和gc之前老年代的对比：如果是一次fullgc后，剩余对象不多。那么说明你eden区设置太小，导致短生命周期的对象进入了old区；如果一次fullgc后，old区回收率不大，那么说明old区太小。
- 持久代是否被写满。