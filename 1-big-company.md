网页地址:http://blog.csdn.net/u011676417/article/details/69076759
##### 一、数据结构和算法：
- 1、volatile：
	- 保证可见性，禁止指令重排序，**但是不能保证可见性**
- 2、transient：
	- Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient
##### 二、java虚拟机：
- GC
	- 对象什么时候会被GC:
		- 引用计数算法：给对象添加一个引用计数器，每当有一个地方引用它的时候，计数器就加1，当失效的时候就减1；任何时刻计数器为0的对象就是不可能再被时候的；优点是简单，缺点：objA.instance=objB,objB.instance=objA,实际上这两个对象不能使用了，但还是相互有引用，虚拟机不能回收它们；虚拟机不是通过引用记数法判断对象存活的；
		- 可达性分析算法
			- 基本思路：通过一系列称为“GC Roots"的对象作为起始点，重这些节点开始向下搜索，搜索所走过的路径称为引用链(Refrence Chain),当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明这个对象是不可用的。
			- java语言中：可以作为GC Roots的对象包括以下几种：
				- 虚拟机栈（栈帧中的本地变量表）中引用的对象
				- 方法去中类静态属性所引用的对象
				- 方法区中常量引用的对象
				- 本地方法栈中JNI(即一般说的native方法)引用的对象
	    - 引用：
		    - 强引用：只要强引用存在，垃圾收集器永远不会回收掉被引用的对象
		    - 软引用（soft Reference）：在系统将要发生内存溢出异常之前，将会把这些对象列入回收返回之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。jdk1.2以后才有。
		    - 弱引用：被弱引用关联的对象只能生存到下一次垃圾回收发生之前，当垃圾收集器工作时，无论当前内存时候足够，都会回收弱引用。jdk1.2以后才有。
		    - 虚引用：一个对象是否有虚引用的存在，完全不会对其生产时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能够在这个对象被回收时收到一个通知。  jdk1.2以后才有。
		- 没有被标记的对象，也不会立刻被回收，如果有finalize()方法，系统会将它加入到F-queue中，在finalize方法调用的时候他可以让别的引用再指向它，这样就不会被回收，但是finalize()方法只被系统执行一次，再次没有引用不会被调用了