# spring 事务
- 事务的基本特性：ACID
	- ⑴ 原子性（Atomicity）
	原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。
	- ⑵ 一致性（Consistency）
　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
	- ⑶ 隔离性（Isolation）
　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
	- ⑷ 持久性（Durability）
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
- 事务的隔离级别：
	-  ① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
	-  ② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
	-  ③ Read committed (读已提交)：可避免脏读的发生。
	-  ④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证
- 如果不考虑事务隔离级别，将会产生如下问题：
	- 1、脏读：一个事务读取了另一个事务改写但还没有提交的数据，如果这些数据被回滚，则读到的数据是无效的。
	- 2、不可重复读：在同一个事务中，多次读取同一个数据返回的结果有所不同。
	- 3、幻读（虚读）  ：一个事务读取了几行记录之后，另一个事务插入了一些记录(已经提交)，在后来的查询中，第一个事务就会发现有些原来没有的记录。<br/> &emsp;&emsp;幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。
- transactionDefinition定义的隔离级别：  
	- DEFAULT：使用后端数据库的默认隔离级别（mysql默认采用的是repeatable_read这个隔离级别，oracle默认采用的是read_commited）
	- read_uncommited 读未提交 ：脏读√      不可重复读√    幻读 √
	- read_commited    读已提交：脏读×      不可重复读√    幻读√
	- repeatable_read    可重复读  ：脏读×      不可重复读×    幻读√   
	- serializable          可串行：脏读×      不可重复读×    幻读×
- spring事务传播行为：旨在解决service层方法产生的事务相互调用的问题， Spring事务接口TransactionDefinition定义的事务的传播行为（前三个一类（如果第一个有事务，则用第一个的），中间三个一类（两个事务没有在同一个事务里面，保证两个事务不在同一个事务里面），最后一个一类（嵌套））：
	- **propagation_required**：支持当前事务，若不存在就新建一个；     （保证两个方法在一个事务中）
	- propagation_supports：支持当前事务，若不存在就不使用事务； 
	- propagation_mandatory：支持当前事务，若不存在，抛出异常； 
	- **propagation_requires_new**：如果有事务存在，挂起当前事务，创建一个新的事务；（保证两个方法不在同一个事务当中）
	- propagation_not_supported：以非事物的方式运行，如果有事务存在，挂起当前事务；
	- propagation_never：以非事物的方式运行，如果有事务存在，抛出异常；
	- **propagation_nested**：如果当前事务存在，则嵌套事务执行；（a事务执行完，设置一个保存点，然后再执行b方法，若没有异常一起提交，若有异常，可以回滚到保存点也可以回滚到最初始状态
- spring 支持两种事物管理方式
	- 1.编程式的事物管理
		- 在实际应用中很少使用
	    - 通过TransactionTemplate手动管理事务
	- 2.使用xml配置声明式事务
	   - 开发中推荐使用（代码侵入性最小）
	   - spring的声明式事务是**通过aop实现**的
