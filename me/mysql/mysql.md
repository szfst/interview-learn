# mysql
- 什么影响了数据库的性能：
	- sql查询速度
	- 服务器硬件
	- 网卡流量
	- 磁盘IO
	- 大表（解决：分库分表、对历史数据归档）	
	- 大事务
	- 服务器的操作系统
	- 数据库的存储引擎
	- 数据库的参数配置
	- **mysql表结构的设计和sql语句的优化**：最重要的优化方式
- mysql的插件式存储引擎（所有的引擎都以.frm文件作为表结构信息存储问价）
	- 存储引擎针对表来说，不是针对库，一个库中不同表可以使用不同的存储引擎 （虽然不建议这么做）
	- MyISAM：不支持事务，表级锁（mysql5.5之前默认使用的存储引擎）；由MYD（数据）和MYI（索引）组成，FRM存储表结构；
		- 特性：
			- 1、并发性和锁级别：只读应用并发性好
			- 2、表损坏修复：不是很好的支持
			- 3、支持全文索引、前缀索引
			- 4、表支持数据压缩
		- 适用场景：
			- 非事务型应用
			- 只读应用 
			- 空间类应用（存储gps数据等）
	- InnoDB：事务级存储引擎，完美支持行级锁，事务ACID特性
		- mysql5.5之后默认使用的存储引擎
		- innoDB使用表空间进行数据存储，建议使用独立表空间存储数据
		- 行级锁是由搜索引擎底层实现的
		- 锁用于实现事务的隔离性，管理共享资源的并发访问
		- 锁的类型：
			- 共享锁（读锁）
			- 独占锁（写锁）
		- 锁的粒度：表级锁，行级锁，列级锁
		- 适用场景：**mysql5.7以后，支持全文索引和空间函数**。适合大部分的OLTP应用
	- CSV存储引擎：
		- 数据以文本方式存储在文件中，.csv文件存储表内容，.csm文件存储表的元数据如表状态和数据量，.frm文件存储表结构信息
		- 特点：以.csv格式进行数据存储，所有的列的数据都不能为null，不支持索引，不适合大表，不适合在线处理，可以对数据文件直接进行编辑
		- 使用场景：适合作为数据交换的中间表 
	- Archive
		- 以zlib对表数据进行压缩，磁盘i/o更少
		- 数据存储在arz为后缀的文件中
		- 特点：只支持select和insert操作，只允许在自增id列上添加索引 
		- 适用场景：日志和数据采集类应用
	- memory：也叫做heap存储引擎，所有的数据和索引都存储在内存中
		- 特点：
			- 支持hash索引（适合等值查询）和btree索引（适合范围查找），默认是hash索引
			- 所有的字段都有默认的长度varchar（10）
			- 不支持BLOG和TEXT等的大字段
			- 使用表级锁
			- 使用场景：用于查找或者是映射表，例如邮编和地区的映射表；用于保存数据分析中产生的中间表；用于缓存周期性聚合数据的结果表。
			- 数据容易丢失，所以要求数据可再生
		- federated
			- 提供了访问远程mysql服务器上表的方法
			- 本地不存储数据，数据全部放到远程服务器上面
			- 本地需要保存表结构和远程服务器的链接信息
			- 使用场景：偶尔统计分析和手工查询
- varchar：变长字节
- 不要使用字符串存储日期类型：日期时间类型通常比时间类型所占用的存储空间小；日期时间类型在进行查找过滤时可以利用日期来进行对比；日期时间类型还有丰富的处理函数，可以方便地对日期来计算。使用int存储日期时间不如使用timestamp类型
- mysql主从复制的优点：
	- 实现在不同服务器上的数据分布
	- 实现数据读取时的负载均衡
	- 增强了数据的安全性
	- 实现了数据的高可用和故障切换
	- 实现数据库在线升级
- binlog_status  = row比较好（数据一致性得到了保证，就连uuid这些主键的产生也能一样）
- Btree索引也可以进行等值查询
- Btree索引的使用限制
	- 如果不是按照索引最左列进行查找，则无法使用索引
	- 使用索引时不能跳过中间的列
	- not in 和 <>不无法使用索引
	- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引
- hash索引是基于哈希表实现的，只有查询条件精确匹配hash索引中的所有列时，才能使用hash索引。缺点：无法进行范围查询，无法进行排序，无法部分匹配查找，hash码可能存在hash冲突。
- 索引优化策略 
	- 索引列上不能使用表达式或者函数
	- 前缀索引和索引列的选择性越高，查询效率越高。例如主键索引的选择性最大，效率越高。又例如在性别的这个列上添加索引，选择性低，效率低。
	- 学会使用联合索引。如何选择索引列的顺序也重要。
		- 经常被使用到的列可以放在前面（根据实际情况，选择性差的索引最好不要放前面）
		- 选择性高的列优先
		- 宽度小的列优先
	- 学会使用覆盖索引
		- 可以优化缓存，减少磁盘io操作
		- 可以减少随机io，把随机io操作变为顺序io操作
		- 可以避免对innodb主键索引的二次查询
		- 可以避免myisam表进行系统调用
		- 无法使用的情况：
			- 存储引擎不支持覆盖索引
			- 查询中包含太多的列
			- 使用了双%的like查询
	- 使用索引扫描优化排序
	- 使用hash索引优化查询
	- 利用索引优化锁 ：索引可以减少锁定的行数；加快锁的释放数据，加快处理速度。
- 索引的维护和优化
	- 删除重复和冗余的索引
	- 查找未被使用过的索引
	- 更新索引统计信息及减少索引碎片
- 如何获取有问题的sql
	- 通过用户反馈
	- 通过慢查询日志
		- mysqldumpslow
		- pt-query-digest
	- 实时获取存在性能问题的sql(利用mysql内置的表)
		- select idj,user,host,DB,command,time,state,info from information_schema.PROCESSLIST WHERE TIME > 60
- mysql如何执行查询
	- 1、客户端发送sql请求给服务器
	- 2、服务器检查是否可以在查询缓存中命中该sql（有难度，而且要对缓存加锁，建议关闭）
	- 3、服务端进行sql解析，预处理，再由优化器生成对应的执行计划
		- 子过程
			- 解析sql
			- 预处理
			- 优化sql执行计划
	- 4、根据执行计划，调用存储引擎api来查询数据
	- 5、将结果返回给客户端 
- 确定查询处理各个阶段所消耗的时间
	- 使用profile
		- set profiling=1;
		- 执行查询
		- show profiles;
		- show profile for query query_id;
	- 使用performance_schema
- 优化sql
	- 使用left join 代替not in
	- 使用汇总表优化查询：提前把要统计的数据汇总到汇总表里面以供后续的查询使用
- 分库分表
	- 什么是分库分表，还有表的分片
	- 如何生成全局唯一id:
		- **redis** 
		- 等步长auto_increment
		- 用一台机器专门生成id
	- 工具oneProxy   
- 检查主从复制的数据是否一致
	- 工具：pt-table-checksum 
