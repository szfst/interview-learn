#### 详细jvm内存模型
（深入理解jvm那本书讲得很好）
- 主内存和工作内存
- 内存间交互操作
- volatile型变量的特殊规则
- 对于龙和double型变量的特殊规则
- 原子性，可见性和有序性
- happens-before原则
#### 讲讲什么情况下回出现内存溢出，内存泄漏？
- 内存溢出：用专业点的语言来说内存溢出，就是你申请内存容量的时候，系统无法给到你足够的内存容量大小，你申请了一个Integer类型的大小空间，但是你却往里面放long类型才能存的下的数据，这个时候就会内存溢出（Out Of Memory）。
- 内存泄露：你向系统申请到了你想要的内存空间（new），但是使用完了之后却不归还（delete），结果你申请到的内存空间你自己也访问不到（也许你把地址搞丢了），系统也无法分配该空间给其他的程序。这就是一次泄漏。内存泄漏的堆积，时间长了，你的内存空间会一点点的变小，**Memory leak最终会导致Out Of Memory**,因为你的可用的内存空间会越来越小，可分配给其他程序的容量也越来越小，很容易就会造成OOM. 
- **如何定位内存泄露：jmap -histo:live [pid]** 可以看到每个对象的存活情况，包括有多少个对象，占用多少字节。
https://blog.csdn.net/aasgis6u/article/details/54928744
#### 说说Java线程栈 
- jstack：查看线程快照
- java虚拟机栈：每个方法在执行的同时都会创建一个帧栈用于存储局部变量表，炒作数栈，动态链接，方法出口等。每一个方法从调用到执行完成的过程，对应着一个帧栈在虚拟机中入栈到出栈的过程。
#### JVM 年轻代到年老代的晋升过程的判断条件是什么呢？
- 年龄到了就进入老年代（默认15次，每Minor GC一个年龄就加1，可以设置MaxTenuringThreshold大小设置次数）
- 大对象直接进入老年代（可以设置PretenureSizeThreshold大小）
- 动态对象年龄判定：如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代。
#### JVM 出现 fullGC 很频繁，怎么去线上排查问题？
https://www.zhihu.com/question/23512213
- 查看代码中是否显示调用了System.gc(),在代码中显示调用会触发full GC。Full GC堆整个堆进行整理，包括Young、Tenured和Perm，所以比Scavenge GC要慢。
- 老年代是否被写满。
	- 看日志，gc之后老年代和gc之前老年代的对比：如果是一次fullgc后，剩余对象不多。那么说明你eden区设置太小，导致短生命周期的对象进入了old区；如果一次fullgc后，old区回收率不大，那么说明old区太小。
- 持久代是否被写满。
#### 类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式
https://www.cnblogs.com/lanxuezaipiao/p/4138511.html
- 但是，我们**可以自己定义一个类加载器**来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载
- 破坏双亲委派模型：
	- 自定义类加载器
	- jndi，jdbc
	- 热部署（tomcat）
#### 类的实例化顺序
- 静态方法，构造方法，先基类后子类
- https://blog.csdn.net/skdzyl1/article/details/53108142
- 如下：
	- 1.首先是父类的静态变量和静态代码块（看两者的书写顺序）；
    - 2.第二执行子类的静态变量和静态代码块（看两者的书写顺序）；
    - 3.第三执行父类的成员变量赋值
    - 4.第四执行父类类的构造代码块
    - 5.第五执行父类的构造方法（）
    - 6.执行子类的构造代码块
    - 7.第七执行子类的构造方法（）；
- 构造方法最后调用！！！！成员变量优先构造代码块优先构造方法！