##### 一、java堆
- **新生代分为eden区，s0区、s1区，s0和s1也被称为from和to区域，他们是两块大小相等并且可以互换角色的空间**。
- 绝大多数情况下，对象首先分配在eden区，在一次新生代回收后，如果对象还存活，则会进入s0或者s1区，之后每次、经过一次新生代回收，如果对象存活则它的年龄就会加1，当对象达到一定的年龄后，则会进入老年代。
##### 二、jvm参数
- -XX:+PrintGC:使用这个参数，虚拟机启动后，只要遇到GC就会打印日志
- -Xms:设置java程序启动时初始堆的大小
- -Xmx：设置java程序能获得的最大堆的大小
- 总结：在实际工作中，我们可以直接将初始化堆的大小与最大堆的大小设置相等，这样做的好处是可以减少程序运行时候的垃圾回收次数，从而提高性能
- Xmn:可以设置新生代的大小，设置一个比较大的新生代会减少老年代的大小，这个参数堆系统的性能以及GC行为由很大的影响，新生代大小一般会设置为整个堆空间的1/3到1/4左右
- -XX:SurvivorRatio：用来设置新生代eden空间和from/to空间的比例。含义：-XX:SurvivorRatio=eden/from=eden/to
- 总结：不同的堆分配情况，堆系统执行会产生一定的影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽可能将对象预留在新生代，减少老年代的GC次数；除了可以设置新生代的绝对大小（-Xmn）,还可以使用（-XX:NewRatio）设置新生代和老年代的比例：-XX:NewRation=老年代/新生代
- Xss 来指定线程的最大栈空间，整个参数也直接决定了函数可调用的最大参数
- -XX:MaxPermSize，和java堆一样，方法区是一块所有线程共享的内存区域，它用于保存系统的类信息，方法区（永久区）可以保存多少信息可以对其进行配置，在默认情况下，-XX:MaxPermSize为64MB，如果系统运行时产生大量的类，就需要设置一个先对合适的方法区，一面出现永久区内存溢出的问题。
-XX:PermSize=64M -XX:MaxPermSize=64M
- **直接内存**也是java程序中非常重要的组成部分，特别是广泛用在**NIO**中，直接内存跳过了java堆，是java程序可以直接访问原生堆空间，因此在一定程度上加快了内存空间的访问数据。但是做直接内存一定可以提高内存访问速度也不见得，具体情况具体分析。相关参数配置：-XX:MaxDirectMemorySize(1.7以后配置了之后也不怎么生效)，如果不设置默认值为最大堆空间，即-Xmx。直接内存使用达到上限是，就会触发垃圾回收，如果不能有效地释放空间，也会引起系统的OOM.
##### 三、垃圾回收算法
- 引用计数法：没法处理循环引用问题
- 标记清除发：
- 复制算法：**java中新生代用的就是这个算法**
- 标记压缩：就是标记整理，**老年代的回收算法**
- 分代算法
- 分区算法：其主要就是将整个内存分为n多个小的独立空间，每个小空间都可以独立使用，这样细粒度地控制一次回收多少个小空间和哪些小空间，而不是对整个空间进行GC，从而提升性能，并减少GC的停顿时间。 （G1回收器）
##### 四、对象如何进入老年代
- 一般而言对象首次创建会被放置在新生代的eden去，如果没有GC介入，则对象不会俩开eden。晋升为老年代的参数默认为15，-XX:MaxTenuringThreshold。另外大对象（新生代eden去无法装入时，也会直接进入老年代）。jvm里面有个参数可以设置对象的大小超过在只能的大小之后，直接进入老年代。-XX:PretenureSizeThreshold；但是要小心TLAB：虚拟机对于体积不大的对象，会优先把数据分配到TLAB区域中，因此就是去了再老年代分配的机会。使用-XX:-UseTLAB禁用TLAB区(+号表示使用，-号表示禁用)
- TLAB全称是Thread Local Allocation Buffer，即线程本地分配缓存，从名字上看是一个线程专用的内存分配区域，是为了加速对象分配而生的。（volatile关键字与这个区域有关）
##### 五、垃圾收集器
- 串行回收器：
	- 分类：
		- Serial：新生代串行回收器
		- Serial Old：老年代串行回收器
	- 配置：使用-XX:+UseSerialGC 参数可以设置使用新生代串行回收器和老年代串行回收器 
- 并行回收器：
	- 分类：
		- ParNew：新生代并行回收器，复制算法
		- Parallel Scavenge（ParallelGC）：新生代并行回收器，复制算法，和上面的对比，它更加关注系统的吞吐量，可以用-XX:+UseAdaptivSizePolicy打开自适应模式
		- Parallel Old（ParallelOldGC）：老年代并行回收器，Parallel Scavenge老年代版本，标记-整理算法
- CMS收集器：老年代，标记清除
	- 介绍：Concurrent Mark Sweep意为并发标记清除，他使用的是标记清除算法，主要**关注系统停顿时间**。
	- 使用-XX:+UseConcMarkSweepGC进行设置
	- 使用-XX:ConcGCThreads设置并发线程数量
	- CMS并不是独占的回收器，也就是说CMS回收的过程中，程序仍然在不停地工作，又会有新的垃圾不断产生，所以在使用CMS的过程中应该确保应用程序的内存足够可用。CMS不会等到应用程序饱和的时候才去回收垃圾，而是在某一阈值的时候开始回收，回收阈值可用指定的参数进行配置：-XX:CMSInitiatingOccupancyFraction来指定，默认为68，也就是说当老年代的空间使用率达到68%的是偶，会执行CMS回收，如果内存使用率增长很快，在CMS执行的过程中，已经出现了内存不足的情况，此时CMS会回收失败，虚拟机将启动老年代串行回收器进行垃圾收集，这回导致应用程序中断，知道垃圾收集完成后才能正常工作，这个过程GC的停顿时间比较长，所以-XX:CMSInitiationOccupancyFraction的设置要根据实际情况。标记清除算法有个缺点就是存在内存碎片的问题，那么CMS有个参数设置-XX:+UserCOMSCompactAtFullCollection可以使CMS回收完成之后进行一次碎片整理，-XX:CMSFullGCsBeforeCompaction参数可以设置进行多少次CMS回收之后，对内存进行一次压缩。
- G1收集器：G1回收器（Garbage-Firest）是在jdk1.7中提出的垃圾收集器，从长期目标来看是为了取代CMS收集器，G1收集器拥有独特的垃圾回收策略，G1属于分带垃圾回收器，区分新生代和老年代，依然有eden和from/to区，它并不要求整个eden区或者新生代，老年代的空间都连续，它使用了分区算法。
	- 并行性：G1回收器期间可以有多个线程同时工作
	- 并发性：G1拥有与应用程序交替执行能力，部分工作可以与应用程序同时执行，在整个GC期间不会完全阻塞应用程序
	- 分代GC：G1仍然是一个分代的收集器，但是他是**兼顾新生代和老年代一起工作**，之前的垃圾收集器他们或者在新生代工作，或者在老年代工作，因此这是一个很大的不同。
	- 空间整理：G1在回收过程中，不会像CMS那样在若干次GC后需要进行碎片整理，G1采用了有效复制对象的方式，减少空间碎片。
	- 可预见性：由于分区的原因，G1可以值选择部分区域进行回收，缩小了回收的范围，提升了性能
	- 使用-XX:+UseG1GC应用G1收集器
	- 使用-XX:MaxGCPauseMillis指定最大停顿时间
	- 使用-XX:ParallelGCThreads设置并行回收的线程数量